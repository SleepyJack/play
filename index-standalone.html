<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
  <title>Music Player</title>
  <style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
  overflow: hidden;
  width: 100vw;
  height: 100vh;
  background: #f0f0f0;
  user-select: none;
  -webkit-user-select: none;
}

/* ===== CHILD MODE ===== */
#child-mode {
  display: none;
  width: 100%;
  height: 100%;
  position: relative;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

#child-mode.active {
  display: flex;
  flex-direction: column;
}

/* Hidden unlock area */
.unlock-area {
  position: absolute;
  top: 0;
  right: 0;
  width: 80px;
  height: 80px;
  z-index: 1000;
  /* Invisible by default */
}

.unlock-progress {
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0);
  border-radius: 0 0 0 100%;
  transition: background 0.3s ease;
}

.unlock-area.unlocking .unlock-progress {
  background: rgba(255, 255, 255, 0.3);
}

/* Songs grid */
.songs-grid {
  flex: 1;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 20px;
  padding: 20px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.song-tile {
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  transition: transform 0.2s ease, opacity 0.2s ease;
}

.song-tile:active {
  transform: scale(0.95);
  opacity: 0.8;
}

.song-image-container {
  width: 100%;
  aspect-ratio: 1;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  position: relative;
  background: #fff;
}

.song-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.song-placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 3em;
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  color: white;
}

.placeholder-emoji {
  font-size: 2em;
  margin-bottom: 0.2em;
}

.placeholder-initial {
  font-weight: bold;
  font-size: 1.5em;
}

/* Playing indicator on tile - bright blue border */
.song-tile.playing .song-image-container {
  border: 6px solid #00BFFF;
  box-shadow: 0 0 20px rgba(0, 191, 255, 0.6), 0 4px 15px rgba(0, 0, 0, 0.3);
}

.song-name {
  margin-top: 10px;
  font-size: 1em;
  font-weight: 600;
  color: white;
  text-align: center;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  word-wrap: break-word;
  max-width: 100%;
  display: none; /* Hidden in child mode - toddlers can't read */
}

/* Now playing indicator */
.now-playing {
  background: rgba(0, 0, 0, 0.5);
  padding: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(10px);
  cursor: pointer;
  transition: background 0.2s ease;
}

.now-playing:active {
  background: rgba(0, 0, 0, 0.7);
}

.now-playing.hidden {
  display: none;
}

.now-playing-icon {
  width: 80px;
  height: 80px;
  border-radius: 12px;
  opacity: 0.7;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
}

.now-playing-placeholder {
  width: 80px;
  height: 80px;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 2em;
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  color: white;
  opacity: 0.7;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
}

/* Empty state */
.empty-state {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  text-align: center;
  padding: 20px;
}

.empty-state.hidden {
  display: none;
}

.empty-message {
  font-size: 2em;
  font-weight: 600;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

/* ===== PARENT MODE ===== */
#parent-mode {
  display: none;
  width: 100%;
  height: 100%;
  background: #fff;
  flex-direction: column;
}

#parent-mode.active {
  display: flex;
}

.parent-header {
  background: #667eea;
  color: white;
  padding: 15px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.back-button {
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  font-size: 1em;
  cursor: pointer;
  margin-bottom: 10px;
}

.back-button:active {
  background: rgba(255, 255, 255, 0.3);
}

.parent-header h2 {
  margin: 0;
  font-size: 1.5em;
}

.parent-content {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.add-song-btn {
  width: 100%;
  background: #667eea;
  color: white;
  border: none;
  padding: 20px;
  border-radius: 12px;
  font-size: 1.3em;
  font-weight: 600;
  cursor: pointer;
  margin-bottom: 30px;
  box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);
}

.add-song-btn:active {
  background: #5568d3;
  transform: scale(0.98);
}

.parent-content h3 {
  margin: 20px 0 15px 0;
  color: #333;
  font-size: 1.2em;
}

.songs-list {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.song-item {
  background: #f8f9fa;
  border-radius: 12px;
  padding: 15px;
  display: flex;
  align-items: center;
  gap: 15px;
}

.song-item-image {
  width: 60px;
  height: 60px;
  border-radius: 8px;
  object-fit: cover;
  flex-shrink: 0;
}

.song-item-placeholder {
  width: 60px;
  height: 60px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5em;
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  flex-shrink: 0;
}

.song-item-info {
  flex: 1;
  min-width: 0;
}

.song-item-name {
  font-weight: 600;
  font-size: 1em;
  margin-bottom: 5px;
  word-wrap: break-word;
}

.song-item-meta {
  font-size: 0.8em;
  color: #666;
}

.song-item-actions {
  display: flex;
  gap: 8px;
  flex-shrink: 0;
}

.btn-small {
  background: #667eea;
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 0.9em;
  cursor: pointer;
}

.btn-small.btn-danger {
  background: #dc3545;
}

.btn-small:active {
  opacity: 0.8;
}

.settings-section {
  margin-top: 30px;
  padding-top: 20px;
  border-top: 2px solid #e9ecef;
}

.setting-item {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 15px 0;
  font-size: 1em;
}

.setting-item input[type="checkbox"] {
  width: 24px;
  height: 24px;
  cursor: pointer;
}

.info {
  background: #e7f3ff;
  padding: 15px;
  border-radius: 8px;
  margin-top: 15px;
  font-size: 0.95em;
  color: #333;
}

/* Empty songs list */
.songs-list:empty::after {
  content: 'No songs added yet';
  display: block;
  text-align: center;
  color: #999;
  padding: 40px;
  font-style: italic;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.1);
}

::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}
  </style>
</head>
<body>
  <!-- Child Mode (Default) -->
  <div id="child-mode" class="active">
    <!-- Hidden unlock area (top-right corner) -->
    <div id="unlock-area" class="unlock-area">
      <div id="unlock-progress" class="unlock-progress"></div>
    </div>

    <!-- Songs grid -->
    <div id="songs-grid" class="songs-grid">
      <!-- Songs will be dynamically inserted here -->
    </div>

    <!-- Now playing indicator -->
    <div id="now-playing" class="now-playing hidden">
      <!-- Now playing icon will be inserted here dynamically -->
    </div>

    <!-- Empty state -->
    <div id="empty-state" class="empty-state hidden">
      <div class="empty-message">
        <p>No songs yet!</p>
        <p style="font-size: 0.6em; margin-top: 1em;">
          Hold top-right corner for 3 seconds to add songs
        </p>
      </div>
    </div>
  </div>

  <!-- Parent Mode (Hidden) -->
  <div id="parent-mode">
    <div class="parent-header">
      <button id="back-to-child" class="back-button">‚Üê Back to Child Mode</button>
      <h2>Parent Mode</h2>
    </div>

    <div class="parent-content">
      <button id="add-song-btn" class="add-song-btn">+ Add New Song</button>

      <h3>Your Songs:</h3>
      <div id="songs-list" class="songs-list">
        <!-- Songs list will be dynamically inserted here -->
      </div>

      <div class="settings-section">
        <h3>Settings:</h3>
        <label class="setting-item">
          <input type="checkbox" id="keep-screen-on">
          <span>Keep screen on while playing</span>
        </label>
        <div class="info">
          <strong>Unlock gesture:</strong> 3-second press on top-right corner
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden file inputs -->
  <input type="file" id="audio-input" accept="audio/*" hidden>
  <input type="file" id="image-input" accept="image/*" hidden>

  <script>
// ===== DATABASE =====
const DB_NAME = 'ToddlerMusicPlayer';
const DB_VERSION = 1;
const STORE_NAME = 'songs';

let db = null;
let currentAudio = null;
let currentSongId = null;

// Initialize database
async function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };

    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
        objectStore.createIndex('name', 'name', { unique: false });
      }
    };
  });
}

// Database operations
async function addSong(name, audioBlob, imageBlob = null) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);

    const song = {
      name: name,
      audioBlob: audioBlob,
      imageBlob: imageBlob,
      addedDate: new Date().toISOString()
    };

    const request = store.add(song);
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

async function getAllSongs() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.getAll();

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

async function updateSong(id, updates) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const getRequest = store.get(id);

    getRequest.onsuccess = () => {
      const song = getRequest.result;
      Object.assign(song, updates);
      const updateRequest = store.put(song);
      updateRequest.onsuccess = () => resolve();
      updateRequest.onerror = () => reject(updateRequest.error);
    };
    getRequest.onerror = () => reject(getRequest.error);
  });
}

async function deleteSong(id) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.delete(id);

    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// ===== AUDIO PLAYBACK =====
function stopPlayback() {
  if (currentAudio) {
    currentAudio.pause();
    currentAudio = null;
  }
  currentSongId = null;
  updateNowPlaying(null);
  updateSongTiles();
}

function playSong(song) {
  // If clicking the same song, just pause it
  if (currentSongId === song.id) {
    stopPlayback();
    return;
  }

  // Stop current song if playing
  if (currentAudio) {
    currentAudio.pause();
    currentAudio = null;
  }

  // Create and play new audio
  const audioUrl = URL.createObjectURL(song.audioBlob);
  currentAudio = new Audio(audioUrl);
  currentSongId = song.id;

  currentAudio.play().catch(err => {
    console.error('Playback error:', err);
    alert('Could not play this song. Please check the audio file.');
  });

  // Update UI
  updateNowPlaying(song);
  updateSongTiles();

  // Handle song end
  currentAudio.onended = () => {
    currentSongId = null;
    updateNowPlaying(null);
    updateSongTiles();
    URL.revokeObjectURL(audioUrl);
  };
}

function updateNowPlaying(song) {
  const nowPlaying = document.getElementById('now-playing');
  nowPlaying.innerHTML = ''; // Clear contents

  if (song) {
    // Create icon element
    if (song.imageBlob) {
      const img = document.createElement('img');
      img.className = 'now-playing-icon';
      img.src = URL.createObjectURL(song.imageBlob);
      nowPlaying.appendChild(img);
    } else {
      const placeholder = document.createElement('div');
      placeholder.className = 'now-playing-placeholder';

      const emoji = document.createElement('div');
      emoji.textContent = getRandomEmoji();

      const initial = document.createElement('div');
      initial.textContent = song.name.charAt(0).toUpperCase();
      initial.style.fontSize = '0.7em';

      placeholder.appendChild(emoji);
      placeholder.appendChild(initial);
      nowPlaying.appendChild(placeholder);
    }
    nowPlaying.classList.remove('hidden');
  } else {
    nowPlaying.classList.add('hidden');
  }
}

// ===== UI RENDERING =====
async function renderChildMode() {
  const songs = await getAllSongs();
  const grid = document.getElementById('songs-grid');
  const emptyState = document.getElementById('empty-state');

  grid.innerHTML = '';

  if (songs.length === 0) {
    emptyState.classList.remove('hidden');
    return;
  }

  emptyState.classList.add('hidden');

  songs.forEach(song => {
    const tile = createSongTile(song);
    grid.appendChild(tile);
  });
}

function createSongTile(song) {
  const tile = document.createElement('div');
  tile.className = 'song-tile';
  if (currentSongId === song.id) {
    tile.classList.add('playing');
  }

  const imageContainer = document.createElement('div');
  imageContainer.className = 'song-image-container';

  if (song.imageBlob) {
    const img = document.createElement('img');
    img.className = 'song-image';
    img.src = URL.createObjectURL(song.imageBlob);
    imageContainer.appendChild(img);
  } else {
    const placeholder = document.createElement('div');
    placeholder.className = 'song-placeholder';

    const emoji = document.createElement('div');
    emoji.className = 'placeholder-emoji';
    emoji.textContent = getRandomEmoji();

    const initial = document.createElement('div');
    initial.className = 'placeholder-initial';
    initial.textContent = song.name.charAt(0).toUpperCase();

    placeholder.appendChild(emoji);
    placeholder.appendChild(initial);
    imageContainer.appendChild(placeholder);
  }

  const name = document.createElement('div');
  name.className = 'song-name';
  name.textContent = song.name;

  tile.appendChild(imageContainer);
  tile.appendChild(name);

  tile.addEventListener('click', () => playSong(song));

  return tile;
}

function updateSongTiles() {
  const tiles = document.querySelectorAll('.song-tile');
  tiles.forEach((tile, index) => {
    getAllSongs().then(songs => {
      if (songs[index] && currentSongId === songs[index].id) {
        tile.classList.add('playing');
      } else {
        tile.classList.remove('playing');
      }
    });
  });
}

async function renderParentMode() {
  const songs = await getAllSongs();
  const list = document.getElementById('songs-list');

  list.innerHTML = '';

  songs.forEach(song => {
    const item = createSongListItem(song);
    list.appendChild(item);
  });
}

function createSongListItem(song) {
  const item = document.createElement('div');
  item.className = 'song-item';

  // Image or placeholder
  if (song.imageBlob) {
    const img = document.createElement('img');
    img.className = 'song-item-image';
    img.src = URL.createObjectURL(song.imageBlob);
    item.appendChild(img);
  } else {
    const placeholder = document.createElement('div');
    placeholder.className = 'song-item-placeholder';
    placeholder.textContent = song.name.charAt(0).toUpperCase();
    item.appendChild(placeholder);
  }

  // Info
  const info = document.createElement('div');
  info.className = 'song-item-info';

  const name = document.createElement('div');
  name.className = 'song-item-name';
  name.textContent = song.name;

  const meta = document.createElement('div');
  meta.className = 'song-item-meta';
  meta.textContent = song.imageBlob ? 'Has custom image' : 'Using placeholder';

  info.appendChild(name);
  info.appendChild(meta);
  item.appendChild(info);

  // Actions
  const actions = document.createElement('div');
  actions.className = 'song-item-actions';

  const setIconBtn = document.createElement('button');
  setIconBtn.className = 'btn-small';
  setIconBtn.textContent = song.imageBlob ? 'Change Icon' : 'Set Icon';
  setIconBtn.onclick = () => setIconForSong(song.id);

  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'btn-small btn-danger';
  deleteBtn.textContent = 'Delete';
  deleteBtn.onclick = () => deleteSongWithConfirm(song.id, song.name);

  actions.appendChild(setIconBtn);
  actions.appendChild(deleteBtn);
  item.appendChild(actions);

  return item;
}

// ===== MODE SWITCHING =====
let unlockTimer = null;

function setupUnlockGesture() {
  const unlockArea = document.getElementById('unlock-area');

  function startUnlock(e) {
    e.preventDefault();
    unlockArea.classList.add('unlocking');

    unlockTimer = setTimeout(() => {
      switchToParentMode();
    }, 3000);
  }

  function cancelUnlock() {
    unlockArea.classList.remove('unlocking');
    if (unlockTimer) {
      clearTimeout(unlockTimer);
      unlockTimer = null;
    }
  }

  // Touch events (for mobile)
  unlockArea.addEventListener('touchstart', startUnlock);
  unlockArea.addEventListener('touchend', cancelUnlock);
  unlockArea.addEventListener('touchcancel', cancelUnlock);

  // Mouse events (for desktop)
  unlockArea.addEventListener('mousedown', startUnlock);
  unlockArea.addEventListener('mouseup', cancelUnlock);
  unlockArea.addEventListener('mouseleave', cancelUnlock);
}

function switchToParentMode() {
  document.getElementById('child-mode').classList.remove('active');
  document.getElementById('parent-mode').classList.add('active');
  renderParentMode();
}

function switchToChildMode() {
  document.getElementById('parent-mode').classList.remove('active');
  document.getElementById('child-mode').classList.add('active');
  renderChildMode();
}

// ===== FILE HANDLING =====
function handleAddSong() {
  const audioInput = document.getElementById('audio-input');
  audioInput.click();
}

document.getElementById('audio-input').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  // Extract name from filename (remove extension)
  const name = file.name.replace(/\.[^/.]+$/, '');

  try {
    const audioBlob = new Blob([await file.arrayBuffer()], { type: file.type });
    await addSong(name, audioBlob, null);
    await renderParentMode();
    alert(`"${name}" added successfully!`);
  } catch (err) {
    console.error('Error adding song:', err);
    alert('Failed to add song. Please try again.');
  }

  // Reset input
  e.target.value = '';
});

async function setIconForSong(songId) {
  const imageInput = document.getElementById('image-input');

  // Store songId for the change handler
  imageInput.dataset.songId = songId;
  imageInput.click();
}

document.getElementById('image-input').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  const songId = parseInt(e.target.dataset.songId);

  if (!file || !songId) return;

  try {
    const imageBlob = new Blob([await file.arrayBuffer()], { type: file.type });
    await updateSong(songId, { imageBlob });
    await renderParentMode();
    await renderChildMode(); // Refresh child mode too
    alert('Icon updated successfully!');
  } catch (err) {
    console.error('Error setting icon:', err);
    alert('Failed to set icon. Please try again.');
  }

  // Reset input
  e.target.value = '';
  delete e.target.dataset.songId;
});

async function deleteSongWithConfirm(songId, songName) {
  if (!confirm(`Delete "${songName}"?`)) return;

  try {
    // Stop if currently playing
    if (currentSongId === songId) {
      stopPlayback();
    }

    await deleteSong(songId);
    await renderParentMode();
    await renderChildMode();
  } catch (err) {
    console.error('Error deleting song:', err);
    alert('Failed to delete song. Please try again.');
  }
}

// ===== UTILITIES =====
function getRandomEmoji() {
  const emojis = ['üéµ', 'üé∂', 'üé∏', 'üéπ', 'üé∫', 'üéª', 'ü•Å', 'üé§', 'üéß', 'üîä', '‚≠ê', 'üåü', '‚ú®', 'üåà', 'üé®', 'üé™'];
  return emojis[Math.floor(Math.random() * emojis.length)];
}

// ===== EVENT LISTENERS =====
document.getElementById('back-to-child').addEventListener('click', switchToChildMode);
document.getElementById('add-song-btn').addEventListener('click', handleAddSong);

// Now playing click to stop
document.getElementById('now-playing').addEventListener('click', stopPlayback);

// Keep screen on setting
document.getElementById('keep-screen-on').addEventListener('change', (e) => {
  if (e.target.checked) {
    if ('wakeLock' in navigator) {
      navigator.wakeLock.request('screen').catch(err => {
        console.error('Wake lock error:', err);
      });
    }
  }
});

// ===== INITIALIZATION =====
async function init() {
  try {
    await initDB();
    await renderChildMode();
    setupUnlockGesture();
  } catch (err) {
    console.error('Initialization error:', err);
    alert('Failed to initialize app. Please refresh the page.');
  }
}

// Start the app
init();
  </script>
</body>
</html>
